using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace XPathReader
{
    [Generator(LanguageNames.CSharp)]
    public partial class XPathReaderGenerator : IIncrementalGenerator
    {

        /// <summary>Namespace containing all the generated code.</summary>
        private const string GeneratedNamespace = "XPathReader.Generated";
        private const string AttributeName = "XPathReader.Common.GeneratedXPathReaderAttribute";

        /// <summary>Code for a [GeneratedCode] attribute to put on the top-level generated members.</summary>
        private static readonly string _generatedCodeAttribute = $"GeneratedCodeAttribute(\"{typeof(XPathReaderGenerator).Assembly.GetName().Name}\", \"{typeof(XPathReaderGenerator).Assembly.GetName().Version}\")";

        private static readonly string[] _headers =
        [
            "// <auto-generated/>",
            "#nullable enable",
        ];

        private static readonly XPathReaderEmitter _emitter = new XPathReaderEmitter();

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            //Debugger.Launch();
            IncrementalValueProvider<ImmutableArray<GatheringResult?>> xpathReadersToGenerate = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    AttributeName,
                    static (node, _) => node is MethodDeclarationSyntax,
                    GetClassesToGenerate)
                .Where(static m => m is not null)
                .Collect()
                .WithComparer(new ObjectImmutableArraySequenceEqualityComparer());

            context.RegisterSourceOutput(xpathReadersToGenerate, (context, source) =>
            {
                XPathReaderEmitter emitter = new XPathReaderEmitter();
                emitter.Process(context, source!);
            });
        }

        private GatheringResult? GetClassesToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken token)
        {
            var memberSyntax = (MemberDeclarationSyntax)context.TargetNode;
            TypeDeclarationSyntax? typeDec = memberSyntax.Parent as TypeDeclarationSyntax;
            if (typeDec is null)
            {
                return null;
            }

            ImmutableArray<AttributeData> boundAttributes = context.Attributes;
            AttributeData generatedXPathAttribute = boundAttributes[0];
            ImmutableArray<TypedConstant> items = generatedXPathAttribute.ConstructorArguments;
            if (items.Length == 1)
            {
                string? xpaths = items[0].Value as string;
                IMethodSymbol memberSymbol = (IMethodSymbol)context.TargetSymbol;

                bool isNullable = memberSymbol.ReturnType.NullableAnnotation == NullableAnnotation.Annotated;
                // Determine the namespace the class is declared in, if any
                string? ns = memberSymbol.ContainingType?.ContainingNamespace?.ToDisplayString(
                    SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));

                MemberInfo memberInfo = new MemberInfo(
                    typeDec is RecordDeclarationSyntax rds ? $"{typeDec.Keyword.ValueText} {rds.ClassOrStructKeyword}" : typeDec.Keyword.ValueText,
                    ns ?? string.Empty,
                    $"{typeDec.Identifier}{typeDec.TypeParameterList}");

                var current = memberInfo;
                var parent = typeDec.Parent as TypeDeclarationSyntax;

                while (parent is not null && IsAllowedKind(parent.Kind()))
                {
                    current.Parent = new MemberInfo(
                        parent is RecordDeclarationSyntax rds2 ? $"{parent.Keyword.ValueText} {rds2.ClassOrStructKeyword}" : parent.Keyword.ValueText,
                        ns ?? string.Empty,
                        $"{parent.Identifier}{parent.TypeParameterList}");

                    current = current.Parent;
                    parent = parent.Parent as TypeDeclarationSyntax;
                }

                return new GatheringResult(
                        new XPathReaderDataToGenerate(
                            memberInfo,
                            false,
                            GetComparableLocation(memberSyntax),
                            memberSymbol.Name,
                            ((MemberDeclarationSyntax)context.TargetNode).Modifiers.ToString(),
                            isNullable,
                            xpaths ?? string.Empty,
                            new CompilationData
                            {
                                LanguageVersion = context.SemanticModel.Compilation is CSharpCompilation csharpCompilation ? (int)csharpCompilation.LanguageVersion : 703
                            }),
                    null);
            }

            return new GatheringResult(null, new DiagnosticData());
        }

        private static bool IsAllowedKind(SyntaxKind kind)
        {
            return kind is
                SyntaxKind.ClassDeclaration or
                SyntaxKind.StructDeclaration or
                SyntaxKind.RecordDeclaration or
                SyntaxKind.RecordStructDeclaration or
                SyntaxKind.InterfaceDeclaration;
        }

        private static Location GetComparableLocation(SyntaxNode syntax)
        {
            var location = syntax.GetLocation();
            return Location.Create(location.SourceTree?.FilePath ?? string.Empty, location.SourceSpan, location.GetLineSpan().Span);
        }

        private sealed class ObjectImmutableArraySequenceEqualityComparer : IEqualityComparer<ImmutableArray<GatheringResult?>>
        {
            public bool Equals(ImmutableArray<GatheringResult?> left, ImmutableArray<GatheringResult?> right)
            {
                if (left.Length != right.Length)
                {
                    return false;
                }

                for (int i = 0; i < left.Length; i++)
                {
                    bool areEqual = left[i] is { } leftElem
                        ? leftElem.Equals(right[i])
                        : right[i] is null;

                    if (!areEqual)
                    {
                        return false;
                    }
                }

                return true;
            }

            public int GetHashCode(ImmutableArray<GatheringResult?> obj)
            {
                int hash = 0;
                for (int i = 0; i < obj.Length; i++)
                    hash = (hash, obj[i]).GetHashCode();
                return hash;
            }
        }
    }
}
