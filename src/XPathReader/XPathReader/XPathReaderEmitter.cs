using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using XPathReader.Utils;
using XPathReader.XPathParsing;

namespace XPathReader
{
    internal class XPathReaderEmitter
    {
        /// <summary>Code for a [GeneratedCode] attribute to put on the top-level generated members.</summary>
        private static readonly string _generatedCodeAttribute = $"GeneratedCodeAttribute(\"{typeof(XPathReaderGenerator).Assembly.GetName().Name}\", \"{typeof(XPathReaderGenerator).Assembly.GetName().Version}\")";
        private const string GeneratedNamespace = "XPathReader.Generated";

        private static readonly string[] _headers =
[
            "// <auto-generated/>",
            "#nullable enable",
        ];

        int _id = 0;

        private readonly HashSet<string> _names = new();

        internal void Process(SourceProductionContext context, ImmutableArray<GatheringResult> array)
        {
            foreach (GatheringResult result in array.Where(result => result.XPathToGenerate is not null))
            {
                if (_names.Contains(result.XPathToGenerate!.MethodInfo.Name))
                {
                    result.XPathToGenerate.GeneratedName = $"{result.XPathToGenerate.MethodInfo.Name}_{_id++}";
                }
                else
                {
                    _names.Add(result.XPathToGenerate.MethodInfo.Name);
                    result.XPathToGenerate.GeneratedName = result.XPathToGenerate.MethodInfo.Name;
                }

                XPathTree tree = new XPathParser().Parse(result.XPathToGenerate.XPaths);

                IntendedTextWriterExtended textWriter = new(new StringWriter());
                foreach (string header in _headers)
                {
                    textWriter.WriteLine(header);
                }

                EmitRegexPartialMethod(result.XPathToGenerate, textWriter);
                EmitXPathReader(result.XPathToGenerate, tree, textWriter);
                context.AddSource($"{result.XPathToGenerate.GeneratedName}.g.cs", textWriter.ToSourceText());
            }
        }

        private static void EmitRegexPartialMethod(XPathReaderDataToGenerate xpathToGenerate, IntendedTextWriterExtended writer)
        {
            // Emit the namespace.
            var parent = xpathToGenerate.MethodInfo;
            if (!string.IsNullOrWhiteSpace(parent.Namespace))
            {
                writer.WriteLine($"namespace {parent.Namespace}");
                writer.OpenBrace();
            }

            // Emit containing types.
            var parentClasses = new Stack<string>();
            while (parent is not null)
            {
                parentClasses.Push($"partial {parent.Keyword} {parent.Name}");
                parent = parent.Parent;
            }
            while (parentClasses.Count != 0)
            {
                writer.WriteLine($"{parentClasses.Pop()}");
                writer.OpenBrace();
            }

            // Emit the field for the generated instance.
            writer.WriteLine($"[global::System.CodeDom.Compiler.{_generatedCodeAttribute}]");
            bool isStatic = xpathToGenerate.Modifiers.Contains("static");
            writer.WriteLine($"private{(isStatic ? " static" : string.Empty)} global::XPathReader.Common.XPathReader? __f{xpathToGenerate.GeneratedName} = null;");
            writer.WriteLine();

            // Emit the partial method definition.
            writer.WriteLine($"[global::System.CodeDom.Compiler.{_generatedCodeAttribute}]");
            writer.WriteLine($"{xpathToGenerate.Modifiers} global::XPathReader.Common.XPathReader{(xpathToGenerate.IsNullable ? "?" : "")} {xpathToGenerate.MemberName}()");

            writer.OpenBrace();
            writer.WriteLine($"return __f{xpathToGenerate.GeneratedName} ??= new global::{GeneratedNamespace}.{xpathToGenerate.GeneratedName}();");
            writer.CloseBrace();

            // Unwind all scopes
            while (writer.Indent != 0)
            {
                writer.CloseBrace();
            }
        }


        private void EmitXPathReader(XPathReaderDataToGenerate xPathToGenerate, XPathTree tree, IntendedTextWriterExtended writer)
        {
            writer.WriteLine($"namespace {GeneratedNamespace}");
            writer.OpenBrace();

            // We emit usings here now that we're inside of a namespace block and are no longer emitting code into
            // a user's partial type.  We can now rely on binding rules mapping to these usings and don't need to
            // use global-qualified names for the rest of the implementation.
            writer.WriteLine("using System;");
            writer.WriteLine("using System.Collections.Generic;");
            writer.WriteLine("using System.IO;");
            writer.WriteLine("using System.Threading;");
            writer.WriteLine("using System.Xml;");
            writer.WriteLine("using System.Threading.Tasks;");
            writer.WriteLine("using System.CodeDom.Compiler;");
            writer.WriteLine("using System.Runtime.CompilerServices;");
            writer.WriteLine("using XPathReader.Common;");
            writer.WriteLine();

            writer.WriteLine($"[{_generatedCodeAttribute}]");

            writer.WriteLine($"{(xPathToGenerate.CompilationData.LanguageVersion >= 1100 ? "file" : "internal")} sealed class {xPathToGenerate.GeneratedName} : XPathReader");
            writer.OpenBrace();

            SyncXmlReaderTextIntendedTextWriter syncWriter = new(new StringWriter(), "reader")
            {
                Indent = writer.Indent
            };
            AsyncXmlReaderTextIntendedTextWriter asyncWriter = new(new StringWriter(), "reader");
            asyncWriter.Indent = writer.Indent;
            var emitter = new ReadXmlEmmitter(tree);

            TwoXmlReaderTextIntendedTextWriterProxy proxyWriter = new(syncWriter, asyncWriter);
            emitter.GenerateCode(proxyWriter);

            syncWriter.Indent -= writer.Indent;
            asyncWriter.Indent -= writer.Indent;
            writer.Write(syncWriter.ToSourceText().ToString());
            writer.WriteLine();
            writer.Write(asyncWriter.ToSourceText().ToString());

            writer.CloseBrace();// class
            writer.CloseBrace();// namespace
        }
    }
}
