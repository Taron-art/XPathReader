using System.Collections.Immutable;
using ARTX.XPathReader.XPathParsing;
using Microsoft.CodeAnalysis;
using XPathReader.Utils;

namespace ARTX.XPathReader
{
    internal class XPathReaderEmitter
    {
        /// <summary>Code for a [GeneratedCode] attribute to put on the top-level generated members.</summary>
        private static readonly string _generatedCodeAttribute = $"GeneratedCodeAttribute(\"{typeof(XPathReaderGenerator).Assembly.GetName().Name}\", \"{typeof(XPathReaderGenerator).Assembly.GetName().Version}\")";
        private const string GeneratedNamespace = "ARTX.XPath.Generated";
        private const int NumberOfXPathsInComment = 10;
        private static readonly string[] _headers =
[
            "// <auto-generated/>",
            "#nullable enable",
        ];

        int _id = 0;

        internal void Process(SourceProductionContext context, ImmutableArray<GatheringResult> array)
        {
            XPathParser xPathParser = new();
            foreach (GatheringResult result in array.Where(result => result.XPathToGenerate is not null))
            {
                result.XPathToGenerate!.GeneratedName = $"{result.XPathToGenerate.MethodInfo.Name}_{_id++}";

                (XPathTree Tree, HashSet<string> XPaths) parseResult;
                try
                {
                    parseResult = xPathParser.Parse(result.XPathToGenerate.XPaths);

                    foreach (DiagnosticData diagnostic in xPathParser.NonErrorDiagnostics)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(diagnostic.Descriptor, result.XPathToGenerate.DiagnosticLocation, diagnostic.Args));
                    }
                }
                catch (InvalidXPathException ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.InvalidArgument, result.XPathToGenerate.DiagnosticLocation, ex.XPath, ex.Message));
                    continue;
                }
                catch (UnsupportedXPathException ex)
                {
                    context.ReportDiagnostic(Diagnostic.Create(Diagnostics.UnsupportedXPath, result.XPathToGenerate.DiagnosticLocation, ex.XPath, ex.Message));
                    continue;
                }

                IntendedTextWriterExtended textWriter = new(new StringWriter());
                foreach (string header in _headers)
                {
                    textWriter.WriteLine(header);
                }

                EmitRegexPartialMethodOrProperty(result.XPathToGenerate, textWriter, parseResult.XPaths);
                EmitXPathReader(result.XPathToGenerate, parseResult.Tree, textWriter);

                context.AddSource($"{result.XPathToGenerate.GeneratedName}.g.cs", textWriter.ToSourceText());
            }

            foreach (GatheringResult result in array.Where(result => result.DiagnosticData is not null))
            {
                context.ReportDiagnostic(Diagnostic.Create(result.DiagnosticData!.Descriptor, result.DiagnosticData.Location, result.DiagnosticData.Args));
            }
        }

        private static void EmitRegexPartialMethodOrProperty(XPathReaderDataToGenerate xpathToGenerate, IntendedTextWriterExtended writer, HashSet<string> xPaths)
        {
            // Emit the namespace.
            var parent = xpathToGenerate.MethodInfo;
            if (!string.IsNullOrWhiteSpace(parent.Namespace))
            {
                writer.WriteLine($"namespace {parent.Namespace}");
                writer.OpenBrace();
            }

            // Emit containing types.
            var parentClasses = new Stack<string>();
            while (parent is not null)
            {
                parentClasses.Push($"partial {parent.Keyword} {parent.Name}");
                parent = parent.Parent;
            }
            while (parentClasses.Count != 0)
            {
                writer.WriteLine($"{parentClasses.Pop()}");
                writer.OpenBrace();
            }

            // Emit the field for the generated instance.
            writer.WriteLine($"/// <summary>Cached instance for <see cref=\"{xpathToGenerate.MemberName}\"/>.</summary>");
            writer.WriteLine($"[global::System.CodeDom.Compiler.{_generatedCodeAttribute}]");
            bool isStatic = xpathToGenerate.Modifiers.Contains("static");
            writer.WriteLine($"private{(isStatic ? " static" : string.Empty)} global::ARTX.XPath.XPathReader? __f{xpathToGenerate.GeneratedName};");
            writer.WriteLine();

            // Emit the partial method or property definition.

            writer.WriteLine("/// <remarks>");
            writer.WriteLine("/// Looks for the following XPath(s):<br/>");
            writer.WriteLine("/// <code>");
            foreach (string xpath in xPaths.Take(NumberOfXPathsInComment))
            {
                writer.Write("/// ○ ");
                writer.WriteLine(xpath);
            }

            if (xPaths.Count > NumberOfXPathsInComment)
            {
                writer.WriteLine("/// ...");
            }

            writer.WriteLine("/// </code>");
            writer.WriteLine("/// </remarks>");
            writer.WriteLine($"[global::System.CodeDom.Compiler.{_generatedCodeAttribute}]");
            writer.Write($"{xpathToGenerate.Modifiers} global::ARTX.XPath.XPathReader {xpathToGenerate.MemberName}");
            if (xpathToGenerate.IsProperty)
            {
                writer.WriteLine();
                writer.OpenBrace();
                writer.WriteLine("get");
            }
            else
            {
                writer.WriteLine("()");
            }

            writer.OpenBrace();
            writer.WriteLine($"return __f{xpathToGenerate.GeneratedName} ??= new global::{GeneratedNamespace}.{xpathToGenerate.GeneratedName}();");
            writer.CloseBrace();

            // Unwind all scopes
            while (writer.Indent != 0)
            {
                writer.CloseBrace();
            }
        }


        private void EmitXPathReader(XPathReaderDataToGenerate xPathToGenerate, XPathTree tree, IntendedTextWriterExtended writer)
        {
            writer.WriteLine($"namespace {GeneratedNamespace}");
            writer.OpenBrace();

            // We emit usings here now that we're inside of a namespace block and are no longer emitting code into
            // a user's partial type.  We still must use global:: for not our namespace.
            writer.WriteLine("using System.Collections.Generic;");
            writer.WriteLine("using System.Threading;");
            writer.WriteLine("using System.Xml;");
            writer.WriteLine("using System.CodeDom.Compiler;");
            writer.WriteLine("using System.Runtime.CompilerServices;");
            writer.WriteLine("using ARTX.XPath;");
            writer.WriteLine("using ARTX.XPath.Internal;");
            writer.WriteLine();

            writer.WriteLine($"[{_generatedCodeAttribute}]");

            writer.WriteLine($"{(xPathToGenerate.CompilationData.LanguageVersion >= 1100 ? "file" : "internal")} sealed class {xPathToGenerate.GeneratedName} : XPathReader");
            writer.OpenBrace();

            SyncXmlReaderTextIntendedTextWriter syncWriter = new(new StringWriter(), "reader")
            {
                Indent = writer.Indent
            };
            AsyncXmlReaderTextIntendedTextWriter asyncWriter = new(new StringWriter(), "reader");
            asyncWriter.Indent = writer.Indent;
            var emitter = new ReadXmlEmitter(tree);

            TwoXmlReaderTextIntendedTextWriterProxy proxyWriter = new(syncWriter, asyncWriter);
            emitter.GenerateCode(proxyWriter);

            syncWriter.Indent -= writer.Indent;
            asyncWriter.Indent -= writer.Indent;
            writer.Write(syncWriter.ToSourceText().ToString());
            writer.WriteLine();
            writer.Write(asyncWriter.ToSourceText().ToString());

            writer.CloseBrace();// class
            writer.CloseBrace();// namespace
        }
    }
}
